/// <reference types="node" />
import { Primitive } from '@sindresorhus/is';
import { Document, HydratedDocument, Model, Schema, Types } from 'mongoose';
import 'reflect-metadata';
import { Constructor } from 'type-fest';
import { IMongooseClass } from './meta';
export * from './model';
export * from './schema';
export * from './model-helper';
export * from './middleware';
export { default as validators } from './validator';
export declare const ObjectId: typeof Types.ObjectId;
export declare type ObjectId = Types.ObjectId;
declare type ArrayType<T> = T extends Primitive ? Types.Array<T> : Types.Array<Types.Subdocument & T>;
export declare type DocumentType<T> = HydratedDocument<T>;
export declare type RichDocumentType<T extends {
    _id?: unknown;
}> = {
    [TKey in keyof T]: T[TKey] extends Array<infer TValue> ? ArrayType<TValue> : T[TKey] extends Buffer ? Types.Buffer : T[TKey] extends Date ? Date : T[TKey] extends Record<string, unknown> ? Types.Subdocument & T[TKey] : T[TKey];
} & Document<T['_id']>;
/** @deprecated use RichModelType<typeof ModelClass> */
export declare type ModelType<T, THelper = unknown> = Model<DocumentType<T>, THelper>;
export declare type RichModelType<T extends Constructor<unknown>, THelper = unknown> = Model<InstanceType<T>, THelper> & T;
export declare type Ref<T extends {
    _id?: unknown;
}> = T['_id'] | T;
export declare type RefDocument<T extends {
    _id?: unknown;
}> = T['_id'] | DocumentType<T>;
export declare function getSchema<T extends IMongooseClass>(modelClass: T): Schema;
export declare function getModel<T extends IMongooseClass>(modelClass: T): RichModelType<T>;
export declare function getModelName<T extends IMongooseClass>(modelClass: T): string;
export declare function forNestModule<T extends IMongooseClass>(modelClass: T): {
    name: string;
    schema: Schema;
};
