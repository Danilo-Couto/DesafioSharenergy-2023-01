"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mongoId = exports.virtual = exports.methods = exports.query = exports.statics = exports.refArray = exports.ref = exports.enums = exports.type = exports.defaults = exports.unique = exports.hidden = exports.indexed = exports.required = exports.id = exports.array = exports.prop = void 0;
const mongoose_1 = require("mongoose");
const index_1 = require("./index");
const meta_1 = require("./meta");
const util_1 = require("./util");
function prop(options = {}, type) {
    return (target, name) => {
        var _a;
        const pathSchema = (0, meta_1.getMongooseMeta)(target).schema[name] || {};
        type = type || pathSchema['type'] || options.type;
        if (!type) {
            type = (0, util_1.getType)(target, name);
        }
        if (((_a = type['prototype']) === null || _a === void 0 ? void 0 : _a[meta_1.mongooseMeta]) && !pathSchema['type']) {
            type = (0, index_1.getSchema)(type);
        }
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...pathSchema, ...options, ...type ? { type } : {} };
    };
}
exports.prop = prop;
function array(type, options) {
    return (target, name) => {
        var _a, _b, _c;
        let t;
        if ((_a = type === null || type === void 0 ? void 0 : type['prototype']) === null || _a === void 0 ? void 0 : _a[meta_1.mongooseMeta]) {
            t = (0, index_1.getSchema)(type);
        }
        if ((_c = (_b = type === null || type === void 0 ? void 0 : type['type']) === null || _b === void 0 ? void 0 : _b['prototype']) === null || _c === void 0 ? void 0 : _c[meta_1.mongooseMeta]) {
            type['type'] = (0, index_1.getSchema)(type['type']);
        }
        const path = (0, meta_1.getMongooseMeta)(target).schema[name];
        if (!type)
            type = path['type'];
        if (type === mongoose_1.Types.ObjectId) {
            t = mongoose_1.Schema.Types.ObjectId;
        }
        t = t !== null && t !== void 0 ? t : type;
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], ...options, type: t ? [t] : [] };
    };
}
exports.array = array;
function id() {
    return (target, name) => { };
}
exports.id = id;
function required() {
    return (target, name) => {
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], required: true };
    };
}
exports.required = required;
function indexed() {
    return (target, name) => {
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], index: true };
    };
}
exports.indexed = indexed;
function hidden() {
    return (target, name) => {
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], select: false };
    };
}
exports.hidden = hidden;
function unique() {
    return (target, name) => {
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], unique: true };
    };
}
exports.unique = unique;
function defaults(value) {
    return (target, name) => {
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], default: value };
    };
}
exports.defaults = defaults;
function type(type) {
    return (target, name) => {
        var _a;
        if ((_a = type['prototype']) === null || _a === void 0 ? void 0 : _a[meta_1.mongooseMeta]) {
            type = (0, index_1.getSchema)(type);
        }
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], type };
    };
}
exports.type = type;
function enums(values) {
    return (target, name) => {
        if (!Array.isArray(values)) {
            values = Object.values(values);
        }
        (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], enum: values };
    };
}
exports.enums = enums;
function ref(nameOrClass, idType) {
    if (typeof nameOrClass === 'string') {
        return (target, name) => {
            (0, meta_1.getMongooseMeta)(target).schema[name] = { ...(0, meta_1.getMongooseMeta)(target).schema[name], ref: nameOrClass, type: idType };
        };
    }
    else if ('prototype' in nameOrClass && !!nameOrClass.prototype.constructor.name) {
        return (target, name) => {
            if (nameOrClass === undefined) {
                throw new Error(`${target.constructor.name}.${name} reference type is undefined, maybe circular dependence`);
            }
            const field = (0, meta_1.getMongooseMeta)(target).schema[name] || {};
            const isArray = Array.isArray(field['type']);
            if (field['type'] === undefined || idType || isArray && field['type'][0] === undefined) {
                const type = idType || (0, util_1.getType)(nameOrClass.prototype, '_id');
                if (!type) {
                    throw new Error(`cannot get type for ref ${target.constructor.name}.${name} `
                        + `to ${nameOrClass.constructor.name}._id`);
                }
                if (isArray) {
                    field['type'] = [type];
                }
                else {
                    field['type'] = type;
                }
            }
            (0, meta_1.getMongooseMeta)(target).schema[name] = { ...field, ref: (0, meta_1.getMongooseMeta)(nameOrClass.prototype).name };
        };
    }
    else {
        return (target, name) => {
            const field = (0, meta_1.getMongooseMeta)(target).schema[name] || {};
            const isArray = Array.isArray(field['type']);
            if (isArray && !Array.isArray(idType)) {
                idType = [idType];
            }
            if (field['type'] === undefined || idType || isArray && field['type'][0] === undefined) {
                (0, meta_1.getMongooseMeta)(target).schema[name] = { ...field,
                    type: idType,
                    ref: () => {
                        const clazz = nameOrClass();
                        const type = idType || (0, util_1.getType)(clazz.prototype, '_id');
                        if (!type) {
                            throw new Error(`cannot get type for ref ${target.constructor.name}.${name} `
                                + `to ${clazz.constructor.name}._id`);
                        }
                        return (0, meta_1.getMongooseMeta)(clazz.prototype).name;
                    } };
            }
        };
    }
}
exports.ref = ref;
function refArray(nameOrClass, elementType) {
    if (typeof nameOrClass === 'string') {
        return (target, name) => {
            (0, meta_1.getMongooseMeta)(target).schema[name] = {
                ...(0, meta_1.getMongooseMeta)(target).schema[name],
                type: [{ type: elementType, ref: nameOrClass }],
            };
        };
    }
    else if ('prototype' in nameOrClass && !!nameOrClass.prototype.constructor.name) {
        return (target, name) => {
            (0, meta_1.getMongooseMeta)(target).schema[name] = {
                ...(0, meta_1.getMongooseMeta)(target).schema[name],
                type: [{ type: elementType, ref: (0, meta_1.getMongooseMeta)(nameOrClass.prototype).name }],
            };
        };
    }
    else {
        return (target, name) => {
            (0, meta_1.getMongooseMeta)(target).schema[name] = {
                ...(0, meta_1.getMongooseMeta)(target).schema[name],
                type: [{
                        type: elementType,
                        ref: () => {
                            const clazz = nameOrClass();
                            const type = elementType || (0, util_1.getType)(clazz.prototype, '_id');
                            if (!type) {
                                throw new Error(`cannot get type for ref ${target.constructor.name}.${name} `
                                    + `to ${clazz.constructor.name}._id`);
                            }
                            return (0, meta_1.getMongooseMeta)(clazz.prototype).name;
                        },
                    }],
            };
        };
    }
}
exports.refArray = refArray;
function statics() {
    return (target, name) => {
        (0, meta_1.getMongooseMeta)(target.prototype).statics[name] = target[name];
    };
}
exports.statics = statics;
function query() {
    return (target, name) => {
        (0, meta_1.getMongooseMeta)(target.prototype).queries[name] = target[name];
    };
}
exports.query = query;
function methods() {
    return (target, name) => {
        (0, meta_1.getMongooseMeta)(target).methods[name] = target[name];
    };
}
exports.methods = methods;
function virtual() {
    return (target, name, descriptor) => {
        if (descriptor.value) {
            if (typeof descriptor.value !== 'function') {
                throw new TypeError('virtual can only used on class method or getter/setter');
            }
        }
        (0, meta_1.getMongooseMeta)(target).virtuals[name] = descriptor;
    };
}
exports.virtual = virtual;
function mongoId(options = {}, type) {
    options = { validate: index_1.validators.mongoId, ...options };
    return prop(options, type);
}
exports.mongoId = mongoId;
//# sourceMappingURL=schema.js.map